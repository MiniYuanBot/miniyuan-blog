---
// The <Header /> component creates a consistent HTML header.

import { headerConfig } from "@/config";
import { ThemeToggle } from "../ui";
import { Icon } from "../ui";
import TextLink from "./TextLink.astro";
import IconLink from "./IconLink.astro";
---

<header-component class="sticky top-0 z-50 block border-b border-border/50 transition-base bg-background/80">
	<nav class="nav-container">
		<!-- Left: site title -->
		<div class="nav-left">
			<h2 class="site-title">
				<a href={headerConfig.left.link} class="site-link">
					{headerConfig.left.title}
				</a>
			</h2>
		</div>

		<!-- Center: main navigation - hidden on mobile -->
		<div class="nav-center">
			{
				headerConfig.center.map((item) => (
					<TextLink href={item.link}>{item.title}</TextLink>
				))
			}
		</div>

		<!-- Right: icon links - hidden on mobile -->
		<div class="nav-right">
			{
				headerConfig.right.map(({ link, title, icon }) => (
					<IconLink href={link} label={title} icon={icon} />
				))
			}
			<ThemeToggle />
		</div>

		<!-- Mobile: menu button -->
		<div class="nav-mobile">
			<ThemeToggle />
			<button id="toggleMenu" aria-label="Menu" class="icon-button-base">
				<Icon name="menu" class="icon-base" />
			</button>
		</div>
	</nav>
</header-component>

<!-- Mobile Menu Template -->
<template id="mobileMenuTemplate">
	<div
		id="mobileMenuPortal"
		class="mobile-menu-portal"
		style="top: 4.5rem; z-index: 40; max-height: 0; opacity: 0; visibility: hidden; pointer-events: none; padding: 0;"
	>
		<div class="mobile-menu-container">
			<div class="flex flex-col">
				{
					headerConfig.center.map((item, index) => (
						<TextLink href={item.link} isMobile delay={index * 50}>
							{item.title}
						</TextLink>
					))
				}
			</div>

			<div class="mobile-menu-divider"></div>

			<div class="mobile-icon-grid">
				{
					headerConfig.right.map(({ link, title, icon }, index) => (
						<IconLink
							href={link}
							label={title}
							icon={icon}
							isMobile
							delay={(index + headerConfig.center.length) * 50}
						/>
					))
				}
			</div>
		</div>
	</div>
</template>

<script>
	class HeaderComponent extends HTMLElement {
		private mobileMenuPortal: HTMLElement | null = null;
		private menuButton: HTMLElement | null = null;
		private isMenuOpen = false;
		private preScrollY = 0;

		connectedCallback() {
			const template = document.getElementById(
				"mobileMenuTemplate",
			) as HTMLTemplateElement;
			if (template) {
				const clone = template.content.cloneNode(
					true,
				) as DocumentFragment;
				this.mobileMenuPortal =
					clone.getElementById("mobileMenuPortal");
				if (this.mobileMenuPortal)
					document.body.appendChild(this.mobileMenuPortal);
			}

			this.preScrollY = window.scrollY;
			this._updateScrollState(this.preScrollY);

			window.addEventListener(
				"scroll",
				() => {
					const currentScrollY = window.scrollY;
					this.dataset.show = (
						currentScrollY < 350 || currentScrollY < this.preScrollY
					).toString();
					this._updateScrollState(currentScrollY);
					this.preScrollY = currentScrollY;
				},
				{ passive: true },
			);

			this.menuButton = this.querySelector("#toggleMenu");
			this.menuButton?.addEventListener("click", (e) => {
				e.stopPropagation();
				this._toggleMenu();
			});

			this.mobileMenuPortal
				?.querySelectorAll("a")
				.forEach((link) =>
					link.addEventListener("click", () => this._toggleMenu()),
				);

			document.addEventListener("click", (e) => {
				if (
					this.isMenuOpen &&
					!this.contains(e.target as Node) &&
					!this.mobileMenuPortal?.contains(e.target as Node)
				) {
					this._toggleMenu();
				}
			});

			const observer = new MutationObserver(() => {
				if (this.isMenuOpen) this._updateMenuPosition();
			});
			observer.observe(this, {
				attributes: true,
				attributeFilter: ["data-show", "class"],
			});
		}

		private _toggleMenu() {
			this.isMenuOpen = !this.isMenuOpen;
			this.classList.toggle("expanded", this.isMenuOpen);

			if (!this.mobileMenuPortal) return;

			if (this.isMenuOpen) {
				this.mobileMenuPortal.style.visibility = "visible";
				this.mobileMenuPortal.style.pointerEvents = "auto";

				const height = this.mobileMenuPortal.scrollHeight;

				this.mobileMenuPortal.style.maxHeight = `${height}px`;
				this.mobileMenuPortal.style.opacity = "1";
				this.mobileMenuPortal.style.padding = "";
			} else {
				this.mobileMenuPortal.style.maxHeight = "0";
				this.mobileMenuPortal.style.opacity = "0";
				this.mobileMenuPortal.style.visibility = "hidden";
				this.mobileMenuPortal.style.pointerEvents = "none";
				this.mobileMenuPortal.style.padding = "0";
			}

			if (this.isMenuOpen) this._updateMenuPosition();
		}

		private _updateScrollState(scrollY: number) {
			const isScrolled = scrollY > 20;
			this.classList.toggle("is-scrolled", isScrolled);
			this.mobileMenuPortal?.classList.toggle("is-scrolled", isScrolled);
		}

		private _updateMenuPosition() {
			if (this.mobileMenuPortal) {
				this.mobileMenuPortal.style.top = `${this.getBoundingClientRect().bottom + 8}px`;
			}
		}

		disconnectedCallback() {
			this.mobileMenuPortal?.remove();
		}
	}

	customElements.define("header-component", HeaderComponent);
</script>

<style>
	header-component {
		@apply bg-card border-border/50;
	}

	header-component.is-scrolled {
		@apply header-scrolled;
	}

	header-component[data-show="false"]:not(.expanded) {
		@apply header-hidden;
	}

	header-component.expanded {
		transform: translateY(0) !important;
	}

	#mobileMenuPortal {
		transition:
			max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1),
			opacity 0.3s ease,
			padding 0.3s ease,
			visibility 0.3s ease;
		will-change: max-height, opacity;
	}

	#mobileMenuPortal.is-scrolled .p-2 {
		@apply bg-card/92 border-border;
	}

	@media (min-width: 768px) {
		#mobileMenuPortal {
			display: none !important;
		}
	}
</style>
